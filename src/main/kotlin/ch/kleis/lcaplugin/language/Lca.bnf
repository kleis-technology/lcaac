{
  parserClass="ch.kleis.lcaplugin.language.parser.LcaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lca"
  psiImplClassSuffix="Impl"
  psiPackage="ch.kleis.lcaplugin.psi"
  psiImplPackage="ch.kleis.lcaplugin.psi.impl"

  elementTypeHolderClass="ch.kleis.lcaplugin.psi.LcaTypes"
  elementTypeClass="ch.kleis.lcaplugin.psi.LcaElementType"
  tokenTypeClass="ch.kleis.lcaplugin.psi.LcaTokenType"

  tokens=[
      PACKAGE_KEYWORD = 'package'
      SYSTEM_KEYWORD = 'system'
      PROCESS_KEYWORD = 'process'
      SYMBOL_KEYWORD = 'symbol'
      PRODUCT_KEYWORD = 'product'
      LET_KEYWORD = 'let'
      UNIT_KEYWORD = 'unit'
      REFERENCE_UNIT_KEYWORD = 'reference-unit'
      SCALE_KEYWORD = 'scale'
      NAME_KEYWORD = 'name'
      DIMENSION_KEYWORD = 'dimension'
      PARAMETER_KEYWORD = 'parameter'
      PARAMETERS_KEYWORD = 'parameters'
      PRODUCTS_KEYWORD = 'products'
      COPRODUCTS_KEYWORD = 'coproducts'
      INPUTS_KEYWORD = 'inputs'
      EMISSIONS_KEYWORD = 'emissions'
      RESOURCES_KEYWORD = 'resources'
      IMPORT_KEYWORD = 'import'
      INCLUDE_KEYWORD = 'include'
      TEMPLATE_KEYWORD = 'template'
      IDENTIFIER = 'identifier'
      NUMBER = 'number'
      LSQBRACE = 'left-sqbrace'
      RSQBRACE = 'right-sqbrace'
      LPAREN = 'left-paren'
      RPAREN = 'right-paren'
      LBRACE = 'left-bracket'
      RBRACE = 'right-bracket'
      COMA = 'coma'
      STRING_LITERAL = 'string-literal'
      SPACE = "regexp:\s+"
      COMMENT_BLOCK_START = 'comment-block-start'
      COMMENT_BLOCK_END = 'comment-block-end'
      COMMENT_CONTENT = 'comment-content'
      COMMENT_LINE_START = 'comment-line-start'
      PLUS = "plus"
      MINUS = "MINUS"
      DOT = "dot"
      STAR = "star"
      SLASH = "slash"
      HAT = "hat"
      EQUAL = "equal"
      SEMICOLON = "semicolon"
      DOUBLE_QUOTE = "double-quote"
  ]
}

lcaFile ::= package  (definition | let | import)*

package ::= PACKAGE_KEYWORD urn
import ::= IMPORT_KEYWORD urn wildcard?
wildcard ::= DOT STAR
urn ::= uid DOT urn | uid

definition ::= product | process | system | unit

coreExpr ::= product
    | process
    | system
    | block
    | quantity
    | unit
    | exchange

product ::= PRODUCT_KEYWORD uid? LBRACE (nameField | dimField | referenceUnitField)* RBRACE
nameField ::= NAME_KEYWORD EQUAL STRING_LITERAL
dimField ::= DIMENSION_KEYWORD EQUAL uid
referenceUnitField ::= REFERENCE_UNIT_KEYWORD EQUAL unit


process ::= PROCESS_KEYWORD uid? LBRACE (params | px | let)* RBRACE
private px ::= (exchange | block | include)

system ::= SYSTEM_KEYWORD uid? LBRACE (params | ps | let)* RBRACE
private ps ::= (product | process | system | include)

include ::= INCLUDE_KEYWORD urn (LPAREN comma_sep_assignments? RPAREN)?

comma_sep_assignments ::= assignment ((COMA assignment)* COMA?)?
semicolon_sep_assignments ::= (assignment (SEMICOLON? assignment)? SEMICOLON?)*
assignment ::= uid EQUAL coreExpr

let ::= LET_KEYWORD LBRACE semicolon_sep_assignments RBRACE

params ::= PARAMETERS_KEYWORD LBRACE param* RBRACE
param ::= uid (EQUAL coreExpr)?

block ::= (
    INPUTS_KEYWORD
    | PRODUCTS_KEYWORD
    | COPRODUCTS_KEYWORD
    | EMISSIONS_KEYWORD
    | RESOURCES_KEYWORD) LBRACE exchange* RBRACE

exchange ::= quantity variable

quantity ::= quantityTerm ((PLUS | MINUS) quantity)?
quantityTerm ::= quantityFactor ((STAR | SLASH)? quantityTerm)?
quantityFactor ::= quantityPrimitive (HAT NUMBER)?
quantityPrimitive ::= NUMBER variable | LPAREN quantity RPAREN | variable

unit ::= unitFactor ((STAR | SLASH) unit)?
unitFactor ::= unitPrimitive (HAT NUMBER)?
unitPrimitive ::=
    UNIT_KEYWORD uid? LBRACE (symbolField | scaleField | dimField)* RBRACE
    | LPAREN unit RPAREN
    | variable
symbolField ::= SYMBOL_KEYWORD EQUAL STRING_LITERAL
scaleField ::= SCALE_KEYWORD EQUAL NUMBER

variable ::= urn
uid ::= IDENTIFIER

