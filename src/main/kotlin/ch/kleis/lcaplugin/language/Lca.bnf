{
  parserClass="ch.kleis.lcaplugin.language.parser.LcaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lca"
  psiImplClassSuffix="Impl"
  psiPackage="ch.kleis.lcaplugin.psi"
  psiImplPackage="ch.kleis.lcaplugin.psi.impl"

  elementTypeHolderClass="ch.kleis.lcaplugin.psi.LcaTypes"
  elementTypeClass="ch.kleis.lcaplugin.psi.LcaElementType"
  tokenTypeClass="ch.kleis.lcaplugin.psi.LcaTokenType"

  tokens=[
      PACKAGE_KEYWORD = 'package'
      SYSTEM_KEYWORD = 'system'
      PROCESS_KEYWORD = 'process'
      SYMBOL_KEYWORD = 'symbol'
      SUBSTANCE_KEYWORD = 'substance'
      PRODUCT_KEYWORD = 'product'
      LET_KEYWORD = 'let'
      UNIT_KEYWORD = 'unit'
      REFERENCE_UNIT_KEYWORD = 'reference-unit'
      SCALE_KEYWORD = 'scale'
      NAME_KEYWORD = 'name'
      DIMENSION_KEYWORD = 'dimension'
      PARAMETER_KEYWORD = 'parameter'
      PARAMETERS_KEYWORD = 'parameters'
      PRODUCTS_KEYWORD = 'products'
      COPRODUCTS_KEYWORD = 'coproducts'
      INPUTS_KEYWORD = 'inputs'
      EMISSIONS_KEYWORD = 'emissions'
      RESOURCES_KEYWORD = 'resources'
      IMPORT_KEYWORD = 'import'
      INCLUDE_KEYWORD = 'include'
      TEMPLATE_KEYWORD = 'template'
      IDENTIFIER = 'identifier'
      NUMBER = 'number'
      LSQBRACE = 'left-sqbrace'
      RSQBRACE = 'right-sqbrace'
      LPAREN = 'left-paren'
      RPAREN = 'right-paren'
      LBRACE = 'left-bracket'
      RBRACE = 'right-bracket'
      COMA = 'coma'
      STRING_LITERAL = 'string-literal'
      SPACE = "regexp:\s+"
      COMMENT_BLOCK_START = 'comment-block-start'
      COMMENT_BLOCK_END = 'comment-block-end'
      COMMENT_CONTENT = 'comment-content'
      COMMENT_LINE_START = 'comment-line-start'
      PLUS = "plus"
      MINUS = "MINUS"
      DOT = "dot"
      STAR = "star"
      SLASH = "slash"
      HAT = "hat"
      EQUAL = "equal"
      SEMICOLON = "semicolon"
      DOUBLE_QUOTE = "double-quote"
  ]
}

lcaFile ::= package  (definition | let | import)*

package ::= PACKAGE_KEYWORD urn {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiPackage"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiPackageMixin"
}

import ::= IMPORT_KEYWORD urn wildcard? {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiImport"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiImportMixin"
}

wildcard ::= DOT STAR
urn ::= uid DOT urn | uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiUrn"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiUrnMixin"
}

private definition ::= product | process | system | unitLiteral

coreExpr ::= product
    | process
    | system
    | block
    | quantity
    | unit
    | exchange {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiCoreExpression"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiCoreExpressionMixin"
}

product ::= PRODUCT_KEYWORD uid? LBRACE nameField dimField referenceUnitField? RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiProduct"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiProductMixin"
}
nameField ::= NAME_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}
dimField ::= DIMENSION_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}
referenceUnitField ::= REFERENCE_UNIT_KEYWORD EQUAL unit {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiUnitField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiUnitFieldMixin"
}

process ::= PROCESS_KEYWORD uid?
LBRACE (
    params
    | exchange
    | block
    | include
    | let )* RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiProcess"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiProcessMixin"
}

system ::= SYSTEM_KEYWORD uid?
LBRACE (
    params
    | process
    | system
    | include
    | let )* RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiSystem"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiSystemMixin"
}

include ::= INCLUDE_KEYWORD urn (LPAREN comma_sep_assignments? RPAREN)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiInclude"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiIncludeMixin"
}

private comma_sep_assignments ::= assignment ((COMA assignment)* COMA?)?
private semicolon_sep_assignments ::= (assignment (SEMICOLON? assignment)? SEMICOLON?)*
assignment ::= uid EQUAL coreExpr {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiAssignment"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiAssignmentMixin"
}

private let ::= LET_KEYWORD LBRACE semicolon_sep_assignments RBRACE

params ::= PARAMETERS_KEYWORD LBRACE param* RBRACE
param ::= uid (EQUAL coreExpr)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiParameter"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiParameterMixin"
}

block ::= (
    INPUTS_KEYWORD
    | PRODUCTS_KEYWORD
    | COPRODUCTS_KEYWORD
    | EMISSIONS_KEYWORD
    | RESOURCES_KEYWORD) LBRACE exchange* RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiBlock"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiBlockMixin"
}

exchange ::= quantity variable {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiExchange"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiExchangeMixin"
}

quantity ::= quantityTerm ((PLUS | MINUS) quantity)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.quantity.PsiQuantity"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.quantity.PsiQuantityMixin"
}
quantityTerm ::= quantityFactor ((STAR | SLASH) quantityTerm)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.quantity.PsiQuantityTerm"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.quantity.PsiQuantityTermMixin"
}
quantityFactor ::= quantityPrimitive (HAT NUMBER)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.quantity.PsiQuantityFactor"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.quantity.PsiQuantityFactorMixin"
}
quantityPrimitive ::= NUMBER unit | LPAREN quantity RPAREN | variable {
    implements=["ch.kleis.lcaplugin.language.psi.type.quantity.PsiQuantityPrimitive"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.quantity.PsiQuantityPrimitiveMixin"
}

unit ::= unitFactor ((STAR | SLASH) unit)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnit"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitMixin"
}
unitFactor ::= unitPrimitive (HAT NUMBER)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnitFactor"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitFactorMixin"
}
unitPrimitive ::=
    unitLiteral
    | LPAREN unit RPAREN
    | variable {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnitPrimitive"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitPrimitiveMixin"
}
unitLiteral ::= UNIT_KEYWORD uid? LBRACE symbolField scaleField dimField RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnitLiteral"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitLiteralMixin"
}

symbolField ::= SYMBOL_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}
scaleField ::= SCALE_KEYWORD EQUAL NUMBER {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiNumberField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiNumberFieldMixin"
}

variable ::= urn {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiVariable"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiVariableMixin"
}
uid ::= IDENTIFIER {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiUID"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiUIDMixin"
}

