{
  parserClass="ch.kleis.lcaplugin.language.parser.LcaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lca"
  psiImplClassSuffix="Impl"
  psiPackage="ch.kleis.lcaplugin.psi"
  psiImplPackage="ch.kleis.lcaplugin.psi.impl"

  elementTypeHolderClass="ch.kleis.lcaplugin.psi.LcaTypes"
  elementTypeClass="ch.kleis.lcaplugin.psi.LcaElementType"
  tokenTypeClass="ch.kleis.lcaplugin.psi.LcaTokenType"

  tokens=[
      PACKAGE_KEYWORD = 'package'
      PROCESS_KEYWORD = 'process'
      SYMBOL_KEYWORD = 'symbol'
      SUBSTANCE_KEYWORD = 'substance'
      TYPE_KEYWORD = 'type'
      TYPE_EMISSION_KEYWORD = 'Emission'
      TYPE_RESOURCE_KEYWORD = 'Resource'
      TYPE_LAND_USE_KEYWORD = 'Land_use'
      COMPARTMENT_KEYWORD = 'compartment'
      SUB_COMPARTMENT_KEYWORD = 'sub-compartment'
      IMPACTS_KEYWORD = 'impacts'
      META_KEYWORD = "meta"
      FROM_KEYWORD = "from"
      PRODUCTS_KEYWORD = 'products'
      LAND_USE_KEYWORD = 'land_use'
      INDICATOR_KEYWORD = 'indicator'
      VARIABLES_KEYWORD = 'variables'
      UNIT_KEYWORD = 'unit'
      REFERENCE_UNIT_KEYWORD = 'reference-unit'
      ALIAS_FOR_KEYWORD = 'alias_for'
      ALLOCATE_KEYWORD = 'allocate'
      NAME_KEYWORD = 'name'
      DIMENSION_KEYWORD = 'dimension'
      PARAMETERS_KEYWORD = 'parameters'
      INPUTS_KEYWORD = 'inputs'
      EMISSIONS_KEYWORD = 'emissions'
      RESOURCES_KEYWORD = 'resources'
      IMPORT_KEYWORD = 'import'
      IDENTIFIER = 'identifier'
      NUMBER = 'number'
      LSQBRACE = 'left-sqbrace'
      RSQBRACE = 'right-sqbrace'
      LPAREN = 'left-paren'
      RPAREN = 'right-paren'
      LBRACE = 'left-bracket'
      RBRACE = 'right-bracket'
      COMMA = 'comma'
      STRING_LITERAL = 'string-literal'
      SPACE = "regexp:\s+"
      COMMENT_BLOCK_START = 'comment-block-start'
      COMMENT_BLOCK_END = 'comment-block-end'
      COMMENT_CONTENT = 'comment-content'
      COMMENT_LINE = 'comment-line'
      PLUS = "plus"
      MINUS = "MINUS"
      DOT = "dot"
      STAR = "star"
      SLASH = "slash"
      HAT = "hat"
      EQUAL = "equal"
      DOUBLE_QUOTE = "double-quote"
  ]
}

/*
    LCA File
 */

lcaFile ::= package? import* (process | unitDefinition | substance | globalVariables )*

/*
    Package
 */

package ::= PACKAGE_KEYWORD urn {
    implements=["ch.kleis.lcaplugin.language.psi.type.trait.PsiUrnOwner"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.trait.PsiUrnOwnerMixin"
}

import ::= IMPORT_KEYWORD urn {
    implements=["ch.kleis.lcaplugin.language.psi.type.trait.PsiUrnOwner"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.trait.PsiUrnOwnerMixin"
}

/*
    Global variables
 */

globalVariables ::= VARIABLES_KEYWORD LBRACE globalAssignment* RBRACE
globalAssignment ::= quantityRef EQUAL quantityExpression {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiGlobalAssignment"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiGlobalAssignmentMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.global_assignment.GlobalAssignmentStubElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.global_assignment.GlobalAssignmentStub"
}

/*
    Substance
 */

substance ::= SUBSTANCE_KEYWORD substanceRef LBRACE
    nameField
    typeField
    compartmentField
    subCompartmentField?
    referenceUnitField
    ( block_impacts | block_meta )*
    RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiSubstance"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiSubstanceMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.substance.SubstanceStubElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.substance.SubstanceStub"
}

typeField ::= TYPE_KEYWORD EQUAL (TYPE_EMISSION_KEYWORD|TYPE_RESOURCE_KEYWORD|TYPE_LAND_USE_KEYWORD) {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiSubstanceTypeField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiSubstanceTypeFieldMixin"
}

compartmentField ::= COMPARTMENT_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

subCompartmentField ::= SUB_COMPARTMENT_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

block_meta ::= META_KEYWORD LBRACE meta_assignment* RBRACE

meta_assignment ::= STRING_LITERAL EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiMetaAssignment"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiMetaAssignmentMixin"
}

/*
    Fields
 */

nameField ::= NAME_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

dimField ::= DIMENSION_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

referenceUnitField ::= REFERENCE_UNIT_KEYWORD EQUAL unit {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiUnitField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiUnitFieldMixin"
}

symbolField ::= SYMBOL_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

aliasForField ::= ALIAS_FOR_KEYWORD EQUAL quantityExpression {
        implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiQuantityField"]
        mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiQuantityFieldMixin"
}


/*
    Process
 */

process ::= PROCESS_KEYWORD processTemplateRef
LBRACE (
    params
    | variables
    | block_products
    | block_inputs
    | block_emissions
    | block_land_use
    | block_resources
    | block_meta
    )* RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiProcess"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiProcessMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.process.ProcessStubElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.process.ProcessStub"
}

params ::= PARAMETERS_KEYWORD LBRACE assignment* RBRACE

variables ::= VARIABLES_KEYWORD LBRACE assignment* RBRACE

assignment ::= quantityRef EQUAL quantityExpression {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiAssignment"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiAssignmentMixin"
}

/*
    Blocks
 */

block_products ::= PRODUCTS_KEYWORD LBRACE technoProductExchange* RBRACE

block_inputs ::= INPUTS_KEYWORD LBRACE technoInputExchange* RBRACE

block_emissions ::= EMISSIONS_KEYWORD LBRACE bioExchange* RBRACE

block_land_use ::= LAND_USE_KEYWORD LBRACE bioExchange* RBRACE

block_resources ::= RESOURCES_KEYWORD LBRACE bioExchange* RBRACE

block_impacts ::= IMPACTS_KEYWORD LBRACE impactExchange* RBRACE

/*
    Exchanges
 */

technoInputExchange ::= quantityExpression productRef fromProcessConstraint?
fromProcessConstraint ::= FROM_KEYWORD processTemplateRef LPAREN comma_sep_arguments? RPAREN {
    pin=1
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiFromProcessConstraint"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiFromProcessConstraintMixin"
}

private comma_sep_arguments ::= argument (COMMA argument)* COMMA?
argument ::= parameterRef EQUAL quantityExpression {
    implements=["ch.kleis.lcaplugin.language.psi.type.exchange.PsiArgument"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.exchange.PsiArgumentMixin"
}

// TODO: use PsiQuantityField
allocateField ::= ALLOCATE_KEYWORD quantityExpression {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiAllocateField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiAllocateFieldMixin"
}

technoProductExchange ::= quantityExpression productRef allocateField? {
    implements=["ch.kleis.lcaplugin.language.psi.type.exchange.PsiTechnoProductExchange"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.exchange.PsiTechnoProductExchangeMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.techno_product_exchange.TechnoProductExchangeElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.techno_product_exchange.TechnoProductExchangeStub"
}

bioExchange ::= quantityExpression substanceSpec {
    implements=["ch.kleis.lcaplugin.language.psi.type.exchange.PsiBioExchange"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.exchange.PsiBioExchangeMixin"
}

impactExchange ::= quantityExpression indicatorRef {
    implements=["ch.kleis.lcaplugin.language.psi.type.exchange.PsiImpactExchange"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.exchange.PsiImpactExchangeMixin"
}

/*
    Quantity
    Use GrammarKit's expression-related syntax and rules to generate a Pratt parser.
 */
{
    // Allow LR to generate left-associative n-ary operations
    extends("(add|sub|mul|div)QuantityExpression")=binaryOperatorExpression
    extends(".*QuantityExpression")=quantityExpression
}

quantityExpression ::= addGroup
           | mulGroup
           | exponentialQuantityExpression
           | baseGroup

private addGroup ::= addQuantityExpression | subQuantityExpression
private mulGroup ::= scaleQuantityExpression | mulQuantityExpression | divQuantityExpression
private baseGroup ::=  parenQuantityExpression | quantityRef

fake binaryOperatorExpression ::= quantityExpression quantityExpression {
    extends=quantityExpression
    methods=[
        left="/quantityExpression[0]"
        right="/quantityExpression[1]"
    ]
}

addQuantityExpression ::= quantityExpression PLUS quantityExpression
subQuantityExpression ::= quantityExpression MINUS quantityExpression
mulQuantityExpression ::= quantityExpression STAR quantityExpression
divQuantityExpression ::= quantityExpression SLASH quantityExpression
exponentialQuantityExpression ::= quantityExpression HAT NUMBER { methods=[exponent="NUMBER"] }
parenQuantityExpression ::= LPAREN quantityExpression RPAREN
scaleQuantityExpression ::= NUMBER quantityExpression { methods=[scale="NUMBER"]}

/*
    Unit
 */

unit ::= unitFactor ((STAR | SLASH) unit)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnit"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitMixin"
}

unitFactor ::= unitPrimitive (HAT NUMBER)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnitFactor"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitFactorMixin"
}

unitPrimitive ::=
    unitDefinition
    | LPAREN unit RPAREN
    | unitRef {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnitPrimitive"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitPrimitiveMixin"
}

unitDefinition ::= UNIT_KEYWORD unitRef LBRACE symbolField ( dimField | aliasForField) RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnitDefinition"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitDefinitionMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.unit.UnitElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.unit.UnitStub"
}

/*
    Reference
 */

productRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiProductRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiProductRefMixin"
}

quantityRef ::= uid {
    extends=quantityExpression
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiQuantityRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiQuantityRefMixin"
}

substanceRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiSubstanceRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiSubstanceRefMixin"
}

indicatorRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiIndicatorRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiIndicatorRefMixin"
}

unitRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiUnitRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiUnitRefMixin"
}

processTemplateRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiProcessTemplateRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiProcessTemplateRefMixin"
}

parameterRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiParameterRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiParameterRefMixin"
}

/*
   Spec
 */

substanceSpec ::= uid (LPAREN compartmentField (COMMA subCompartmentField )? RPAREN)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.spec.PsiSubstanceSpec"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.spec.PsiSubstanceSpecMixin"
}
/*
    Identifier
 */

urn ::= uid DOT urn | uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiUrn"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiUrnMixin"
}

uid ::= IDENTIFIER {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiUID"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiUIDMixin"
}

