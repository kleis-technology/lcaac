{
  parserClass="ch.kleis.lcaplugin.language.parser.LcaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lca"
  psiImplClassSuffix="Impl"
  psiPackage="ch.kleis.lcaplugin.psi"
  psiImplPackage="ch.kleis.lcaplugin.psi.impl"

  elementTypeHolderClass="ch.kleis.lcaplugin.psi.LcaTypes"
  elementTypeClass="ch.kleis.lcaplugin.psi.LcaElementType"
  tokenTypeClass="ch.kleis.lcaplugin.psi.LcaTokenType"

  tokens=[
      PACKAGE_KEYWORD = 'package'
      PROCESS_KEYWORD = 'process'
      SYMBOL_KEYWORD = 'symbol'
      SUBSTANCE_KEYWORD = 'substance'
      TYPE_KEYWORD = 'type'
      TYPE_EMISSION_KEYWORD = 'Emission'
      TYPE_RESOURCE_KEYWORD = 'Resource'
      TYPE_LAND_USE_KEYWORD = 'Land_use'
      COMPARTMENT_KEYWORD = 'compartment'
      SUB_COMPARTMENT_KEYWORD = 'sub-compartment'
      IMPACTS_KEYWORD = 'impacts'
      META_KEYWORD = "meta"
      FROM_KEYWORD = "from"
      PRODUCTS_KEYWORD = 'products'
      LAND_USE_KEYWORD = 'land_use'
      INDICATOR_KEYWORD = 'indicator'
      VARIABLES_KEYWORD = 'variables'
      UNIT_KEYWORD = 'unit'
      REFERENCE_UNIT_KEYWORD = 'reference-unit'
      ALIAS_FOR_KEYWORD = 'alias_for'
      ALLOCATE_KEYWORD = 'allocate'
      NAME_KEYWORD = 'name'
      DIMENSION_KEYWORD = 'dimension'
      PARAMETERS_KEYWORD = 'parameters'
      INPUTS_KEYWORD = 'inputs'
      EMISSIONS_KEYWORD = 'emissions'
      RESOURCES_KEYWORD = 'resources'
      LABELS_KEYWORD = 'labels'
      IMPORT_KEYWORD = 'import'
      IDENTIFIER = 'identifier'
      MATCH_KEYWORD = 'match'
      NUMBER = 'number'
      LSQBRACE = 'left-sqbrace'
      RSQBRACE = 'right-sqbrace'
      LPAREN = 'left-paren'
      RPAREN = 'right-paren'
      LBRACE = 'left-bracket'
      RBRACE = 'right-bracket'
      COMMA = 'comma'
      STRING_LITERAL = 'string-literal'
      SPACE = "regexp:\s+"
      COMMENT_BLOCK_START = 'comment-block-start'
      COMMENT_BLOCK_END = 'comment-block-end'
      COMMENT_CONTENT = 'comment-content'
      COMMENT_LINE = 'comment-line'
      PLUS = "plus"
      MINUS = "MINUS"
      DOT = "dot"
      STAR = "star"
      SLASH = "slash"
      HAT = "hat"
      EQUAL = "equal"
      DOUBLE_QUOTE = "double-quote"
  ]
}

/*
    LCA File
 */

lcaFile ::= package? import* (process | unitDefinition | substance | globalVariables )*

/*
    Package
 */

package ::= PACKAGE_KEYWORD urn {
    implements=["ch.kleis.lcaplugin.language.psi.type.trait.PsiUrnOwner"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.trait.PsiUrnOwnerMixin"
}

import ::= IMPORT_KEYWORD urn {
    implements=["ch.kleis.lcaplugin.language.psi.type.trait.PsiUrnOwner"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.trait.PsiUrnOwnerMixin"
}

/*
    Global variables
 */

globalVariables ::= VARIABLES_KEYWORD LBRACE globalAssignment* RBRACE
globalAssignment ::= dataRef EQUAL dataExpression {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiGlobalAssignment"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiGlobalAssignmentMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.global_assignment.GlobalAssignmentStubElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.global_assignment.GlobalAssignmentStub"
}

/*
    Substance
 */

substance ::= SUBSTANCE_KEYWORD substanceRef LBRACE
    nameField
    typeField
    compartmentField
    subCompartmentField?
    referenceUnitField
    ( block_impacts | block_meta )*
    RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiSubstance"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiSubstanceMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.substance.SubstanceStubElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.substance.SubstanceStub"
}

typeField ::= TYPE_KEYWORD EQUAL (TYPE_EMISSION_KEYWORD|TYPE_RESOURCE_KEYWORD|TYPE_LAND_USE_KEYWORD) {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiSubstanceTypeField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiSubstanceTypeFieldMixin"
}

compartmentField ::= COMPARTMENT_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

subCompartmentField ::= SUB_COMPARTMENT_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

block_meta ::= META_KEYWORD LBRACE meta_assignment* RBRACE

meta_assignment ::= STRING_LITERAL EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiMetaAssignment"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiMetaAssignmentMixin"
}

/*
    Fields
 */

nameField ::= NAME_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

dimField ::= DIMENSION_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

referenceUnitField ::= REFERENCE_UNIT_KEYWORD EQUAL dataExpression

symbolField ::= SYMBOL_KEYWORD EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.field.PsiStringLiteralField"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.field.PsiStringLiteralFieldMixin"
}

aliasForField ::= ALIAS_FOR_KEYWORD EQUAL dataExpression


/*
    Process
 */

process ::= PROCESS_KEYWORD processRef
LBRACE (
    params
    | labels
    | variables
    | block_products
    | block_inputs
    | block_emissions
    | block_land_use
    | block_resources
    | block_meta
    )* RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiProcess"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiProcessMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.process.ProcessStubElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.process.ProcessStub"
}

labels ::= LABELS_KEYWORD LBRACE labelAssignment* RBRACE
labelAssignment ::= labelRef EQUAL STRING_LITERAL {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiLabelAssignment"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiLabelAssignmentMixin"
}

params ::= PARAMETERS_KEYWORD LBRACE assignment* RBRACE

variables ::= VARIABLES_KEYWORD LBRACE assignment* RBRACE

assignment ::= dataRef EQUAL dataExpression {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiAssignment"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiAssignmentMixin"
}

/*
    Blocks
 */

block_products ::= PRODUCTS_KEYWORD LBRACE technoProductExchange* RBRACE

block_inputs ::= INPUTS_KEYWORD LBRACE technoInputExchange* RBRACE

block_emissions ::= EMISSIONS_KEYWORD LBRACE bioExchange* RBRACE

block_land_use ::= LAND_USE_KEYWORD LBRACE bioExchange* RBRACE

block_resources ::= RESOURCES_KEYWORD LBRACE bioExchange* RBRACE

block_impacts ::= IMPACTS_KEYWORD LBRACE impactExchange* RBRACE

/*
    Exchanges
 */

technoInputExchange ::= dataExpression inputProductSpec
technoProductExchange ::= dataExpression outputProductSpec
bioExchange ::= dataExpression substanceSpec
impactExchange ::= dataExpression indicatorRef

/*
    Quantity
    Use GrammarKit's expression-related syntax and rules to generate a Pratt parser.
 */

dataExpression ::= addGroup
           | mulGroup
           | exponentialQuantityExpression
           | baseGroup

private addGroup ::= addQuantityExpression | subQuantityExpression
private mulGroup ::= scaleQuantityExpression | mulQuantityExpression | divQuantityExpression
private baseGroup ::=  parenQuantityExpression | stringExpression | dataRef

fake binaryOperatorExpression ::= dataExpression dataExpression {
    extends=dataExpression
    methods=[
        left="/dataExpression[0]"
        right="/dataExpression[1]"
    ]
}

addQuantityExpression ::= dataExpression PLUS dataExpression { extends=binaryOperatorExpression }
subQuantityExpression ::= dataExpression MINUS dataExpression { extends=binaryOperatorExpression }
mulQuantityExpression ::= dataExpression STAR dataExpression { extends=binaryOperatorExpression }
divQuantityExpression ::= dataExpression SLASH dataExpression { extends=binaryOperatorExpression }
exponentialQuantityExpression ::= dataExpression HAT NUMBER { extends=dataExpression methods=[exponent="NUMBER"] }
parenQuantityExpression ::= LPAREN dataExpression RPAREN { extends=dataExpression }
scaleQuantityExpression ::= NUMBER dataExpression { extends=dataExpression methods=[scale="NUMBER"]}
stringExpression ::= STRING_LITERAL { extends=dataExpression }


/*
    Unit
 */
unitDefinition ::= UNIT_KEYWORD dataRef LBRACE symbolField ( dimField | aliasForField) RBRACE {
    implements=["ch.kleis.lcaplugin.language.psi.type.unit.PsiUnitDefinition"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.unit.PsiUnitDefinitionMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.unit.UnitElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.unit.UnitStub"
}

/*
    Reference
 */

labelRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiLabelRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiLabelRefMixin"
}

dataRef ::= uid {
    extends=dataExpression
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiDataRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiDataRefMixin"
}

processRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiProcessRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiProcessRefMixin"
}

substanceRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiSubstanceRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiSubstanceRefMixin"
}

indicatorRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiIndicatorRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiIndicatorRefMixin"
}

parameterRef ::= uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.ref.PsiParameterRef"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiParameterRefMixin"
}

/*
   Spec
 */

outputProductSpec ::= uid allocateField? {
    implements=["ch.kleis.lcaplugin.language.psi.type.spec.PsiOutputProductSpec"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.spec.PsiOutputProductSpecMixin"
    elementTypeClass="ch.kleis.lcaplugin.language.psi.stub.output_product.OutputProductElementType"
    stubClass = "ch.kleis.lcaplugin.language.psi.stub.output_product.OutputProductStub"
}
allocateField ::= ALLOCATE_KEYWORD dataExpression

inputProductSpec ::= uid processTemplateSpec? {
    implements=["ch.kleis.lcaplugin.language.psi.type.spec.PsiInputProductSpec"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.spec.PsiInputProductSpecMixin"
}

processTemplateSpec ::= FROM_KEYWORD uid (LPAREN comma_sep_arguments? RPAREN)? matchLabels? {
    pin=1
    implements=["ch.kleis.lcaplugin.language.psi.type.spec.PsiProcessTemplateSpec"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.ref.PsiProcessTemplateSpecMixin"
}
matchLabels ::= MATCH_KEYWORD LPAREN comma_sep_label_selectors? RPAREN

private comma_sep_label_selectors ::= labelSelector (COMMA labelSelector)* COMMA?
labelSelector ::= labelRef EQUAL dataExpression

private comma_sep_arguments ::= argument (COMMA argument)* COMMA?
argument ::= parameterRef EQUAL dataExpression

substanceSpec ::= uid (LPAREN compartmentField (COMMA subCompartmentField )? RPAREN)? {
    implements=["ch.kleis.lcaplugin.language.psi.type.spec.PsiSubstanceSpec"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.spec.PsiSubstanceSpecMixin"
}

/*
    Identifier
 */

urn ::= uid DOT urn | uid {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiUrn"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiUrnMixin"
}

uid ::= IDENTIFIER {
    implements=["ch.kleis.lcaplugin.language.psi.type.PsiUID"]
    mixin="ch.kleis.lcaplugin.language.psi.mixin.PsiUIDMixin"
}

